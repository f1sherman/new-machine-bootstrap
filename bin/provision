#!/bin/bash
# Universal provisioning script for macOS and Codespaces
#
# This script is written in Bash (not Ruby) because:
# - Bash is available by default on both macOS and Codespaces
# - Ruby is not installed by default in GitHub Codespaces
# - Mise (which provides Ruby in Codespaces) isn't configured until after this script runs
#
# This script bootstraps Ansible and runs the main playbook.

set -e

PROVISIONING_START=$(date +%s)
LOGFILE_PATH="/tmp/provision-$(date +%Y%m%d-%H%M%S).log"

timestamp() {
  date -Iseconds
}

log_info() {
  local line="[$(timestamp)] INFO: $1"
  echo "$line"
  echo "$line" >> "$LOGFILE_PATH"
}

log_error() {
  local line="[$(timestamp)] ERROR: $1"
  echo "$line" >&2
  echo "$line" >> "$LOGFILE_PATH"
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

mac_os() {
  [[ "$OSTYPE" == "darwin"* ]]
}

in_codespaces() {
  [[ "$CODESPACES" == "true" ]]
}

say_message() {
  mac_os && say "$1"
  return 0
}

execute_command() {
  log_info "Executing command: $1"
  if ! eval "$1"; then
    log_error "Command failed: $1"
    say_message "provisioning failed"
    exit 1
  fi
}

install_ansible() {
  if mac_os; then
    log_info "Installing Ansible via Homebrew..."
    execute_command "brew install ansible"
  elif command_exists apt-get; then
    log_info "Installing Ansible via apt-get..."
    execute_command "sudo apt-get update && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ansible"
  else
    log_error "Unsupported platform for automatic Ansible installation"
    exit 1
  fi
}

parse_and_print_changes() {
  local output="$1"
  local current_task=""
  local diff_lines=""
  local in_diff=false
  local changes=()
  local hosts=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^TASK\ \[(.+)\] ]]; then
      current_task="${BASH_REMATCH[1]}"
      diff_lines=""
      in_diff=false
    elif [[ "$line" =~ ^---\  ]]; then
      in_diff=true
      diff_lines="$line"$'\n'
    elif $in_diff && [[ "$line" =~ ^(\+\+\+|@@|[-+\ ]) ]]; then
      diff_lines+="$line"$'\n'
    elif $in_diff && [[ ! "$line" =~ ^(\+\+\+|@@|[-+\ ]|[[:space:]]*$|changed:) ]]; then
      in_diff=false
    elif [[ "$line" =~ ^changed:\ \[([^\]]+)\] ]]; then
      local host="${BASH_REMATCH[1]}"
      changes+=("$host|$current_task|$diff_lines")
      hosts+=("$host")
      diff_lines=""
      in_diff=false
    fi
  done <<< "$output"

  if [[ ${#changes[@]} -eq 0 ]]; then
    return
  fi

  echo ""
  echo "============================================================"
  echo "CHANGES SUMMARY"
  echo "============================================================"

  for change in "${changes[@]}"; do
    IFS='|' read -r host task diff <<< "$change"
    echo ""
    echo -e "\033[33m[$host]\033[0m $task"
    if [[ -n "$diff" ]]; then
      while IFS= read -r diff_line; do
        if [[ "$diff_line" =~ ^- ]]; then
          echo -e "\033[31m$diff_line\033[0m"
        elif [[ "$diff_line" =~ ^\+ ]]; then
          echo -e "\033[32m$diff_line\033[0m"
        else
          echo "$diff_line"
        fi
      done <<< "$diff"
    fi
  done

  echo ""
  echo "------------------------------------------------------------"

  # Count changes per host (avoiding associative arrays for Bash 3.2 compatibility)
  local unique_hosts
  unique_hosts=$(printf '%s\n' "${hosts[@]}" | sort -u)
  while IFS= read -r host; do
    [[ -z "$host" ]] && continue
    local count=0
    for h in "${hosts[@]}"; do
      [[ "$h" == "$host" ]] && ((count++))
    done
    if [[ $count -eq 1 ]]; then
      echo "$host: $count change"
    else
      echo "$host: $count changes"
    fi
  done <<< "$unique_hosts"

  echo "============================================================"
}

parse_and_print_deprecation_warnings() {
  local output="$1"
  local -a warning_messages=()
  local current_warning=""

  while IFS= read -r line; do
    if [[ "$line" =~ \[DEPRECATION\ WARNING\]:\ (.+) ]]; then
      current_warning="${BASH_REMATCH[1]}"
    elif [[ -n "$current_warning" && "$line" =~ ^Origin: ]]; then
      warning_messages+=("$current_warning")
      current_warning=""
    elif [[ -n "$current_warning" && -z "${line// }" ]]; then
      current_warning=""
    fi
  done <<< "$output"

  if [[ ${#warning_messages[@]} -eq 0 ]]; then
    return
  fi

  echo ""
  echo "============================================================"
  echo "DEPRECATION WARNINGS"
  echo "============================================================"

  # Count unique warnings (Bash 3.2 compatible - no associative arrays)
  local unique_warnings
  unique_warnings=$(printf '%s\n' "${warning_messages[@]}" | sort -u)
  local total_count=0
  local unique_count=0

  while IFS= read -r warning; do
    [[ -z "$warning" ]] && continue
    local count=0
    for w in "${warning_messages[@]}"; do
      [[ "$w" == "$warning" ]] && ((count++))
    done
    echo ""
    echo -e "\033[33m[${count}x]\033[0m $warning"
    ((total_count += count))
    ((unique_count++))
  done <<< "$unique_warnings"

  echo ""
  echo "------------------------------------------------------------"
  if [[ $total_count -eq 1 ]]; then
    echo "Total: $total_count warning ($unique_count unique)"
  else
    echo "Total: $total_count warnings ($unique_count unique)"
  fi
  echo "============================================================"
}

if ! command_exists ansible-playbook; then
  install_ansible
fi

cmd_parts=("ansible-playbook")
if ! in_codespaces; then
  cmd_parts+=("--ask-become-pass")
fi
cmd_parts+=("--inventory" "localhost,")
cmd_parts+=("--connection" "local")
cmd_parts+=("playbook.yml")
cmd_parts+=("--diff")
cmd_parts+=("$@")

cmd="${cmd_parts[*]}"
log_info "Executing command: $cmd"

output=$(mktemp)
if ! "${cmd_parts[@]}" 2>&1 | tee -a "$LOGFILE_PATH" | tee "$output"; then
  log_error "Command failed: $cmd"
  say_message "provisioning failed"
  rm -f "$output"
  exit 1
fi

output_content=$(cat "$output")
parse_and_print_changes "$output_content"
parse_and_print_deprecation_warnings "$output_content"
rm -f "$output"

elapsed=$(($(date +%s) - PROVISIONING_START))
log_info "Provisioning took $elapsed seconds."

say_message "provisioning complete"

log_info "Log saved to: $LOGFILE_PATH"
