#!/usr/bin/env ruby
# Universal provisioning script for macOS and Codespaces
#
# This script bootstraps Ansible and runs the main playbook.

require 'rbconfig'
require 'time'

PROVISIONING_START = Time.now.to_i
LOGFILE_PATH = "/tmp/provision-#{Time.now.strftime('%Y%m%d-%H%M%S')}.log"
LOGFILE = File.open(LOGFILE_PATH, 'w')

def timestamp
  Time.now.iso8601
end

def log_info(msg)
  line = "[#{timestamp}] INFO: #{msg}"
  STDOUT.puts line
  LOGFILE.puts line
  LOGFILE.flush
end

def log_error(msg)
  line = "[#{timestamp}] ERROR: #{msg}"
  STDERR.puts line
  LOGFILE.puts line
  LOGFILE.flush
end

def mac_os?
  RbConfig::CONFIG['host_os'] =~ /darwin/
end

def in_codespaces?
  ENV['CODESPACES'] == 'true'
end

def command_exists?(cmd)
  system("command -v #{cmd} >/dev/null 2>&1")
end

def say(str)
  return unless mac_os?

  execute_command("say #{str}")
end

def execute_command(cmd)
  log_info("Executing command: #{cmd}")
  system(cmd)
  unless $?.success?
    log_error("Command failed: #{cmd}")
    say 'provisioning failed'
    exit $?.exitstatus
  end
end

def execute_command_with_capture(cmd)
  log_info("Executing command: #{cmd}")
  output_lines = []

  IO.popen(cmd, err: [:child, :out]) do |io|
    io.each_line do |line|
      print line
      LOGFILE.print line
      LOGFILE.flush
      output_lines << line
    end
  end

  exit_status = $?.exitstatus
  unless $?.success?
    log_error("Command failed: #{cmd}")
    say 'provisioning failed'
    exit exit_status
  end

  output_lines.join
end

def parse_changes(output)
  changes = []
  current_task = nil
  diff_lines = []
  in_diff = false

  output.each_line do |line|
    if line =~ /^TASK \[(.+)\]/
      current_task = $1
      diff_lines = []
      in_diff = false
    elsif line =~ /^--- /
      in_diff = true
      diff_lines << line
    elsif in_diff && line =~ /^(\+\+\+|@@|[-+ ])/
      diff_lines << line
    elsif in_diff && line !~ /^(\+\+\+|@@|[-+ ]|\s*$)/
      in_diff = false
    elsif line =~ /^changed: \[([^\]]+)\]/
      host = $1
      changes << {
        host: host,
        task: current_task,
        diff: diff_lines.empty? ? nil : diff_lines.join
      }
      diff_lines = []
      in_diff = false
    end
  end

  changes
end

def print_changes_summary(changes)
  return if changes.empty?

  puts
  puts "=" * 60
  puts "CHANGES SUMMARY"
  puts "=" * 60

  changes.each do |change|
    puts
    puts "\e[33m[#{change[:host]}]\e[0m #{change[:task]}"
    if change[:diff] && !change[:diff].strip.empty?
      change[:diff].each_line do |line|
        case line
        when /^-/
          print "\e[31m#{line}\e[0m"
        when /^\+/
          print "\e[32m#{line}\e[0m"
        else
          print line
        end
      end
    end
  end

  puts
  puts "-" * 60

  host_counts = changes.group_by { |c| c[:host] }.transform_values(&:count)
  host_counts.each do |host, count|
    puts "#{host}: #{count} change#{'s' if count != 1}"
  end

  puts "=" * 60
end

def install_ansible
  if mac_os?
    log_info("Installing Ansible via Homebrew...")
    execute_command("brew install ansible")
  elsif command_exists?('apt-get')
    log_info("Installing Ansible via apt-get...")
    execute_command("sudo apt-get update && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ansible")
  else
    log_error("Unsupported platform for automatic Ansible installation")
    exit 1
  end
end

# Bootstrap Ansible if needed
unless command_exists?('ansible-playbook')
  install_ansible
end

# Build ansible-playbook command
cmd_parts = ['ansible-playbook']
cmd_parts << '--ask-become-pass' unless in_codespaces?
cmd_parts << '--inventory localhost,'
cmd_parts << '--connection local'
cmd_parts << 'playbook.yml'
cmd_parts << '--diff'
cmd_parts.concat(ARGV)

cmd = cmd_parts.join(' ')

# Execute and capture output
output = execute_command_with_capture(cmd)

# Parse and display changes summary
changes = parse_changes(output)
print_changes_summary(changes)

log_info "Provisioning took #{Time.now.to_i - PROVISIONING_START} seconds."

say 'provisioning complete'

log_info "Log saved to: #{LOGFILE_PATH}"
LOGFILE.close
