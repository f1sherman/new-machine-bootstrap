#!/usr/bin/env ruby
# frozen_string_literal: true

# Ensure output is not buffered
$stdout.sync = true
$stderr.sync = true

SCRIPT_DIR = File.expand_path('..', __dir__)
require_relative File.join(SCRIPT_DIR, 'lib', 'codespace_selector')

def main
  codespace_name = begin
    CodespaceSelector.select_codespace(codespace_name: ARGV[0], filter_available: true)
  rescue CodespaceSelector::SelectionError => e
    puts "Error: #{e.message}"
    exit 1
  end

  puts "==> Syncing repository to Codespace: #{codespace_name}"
  puts "    Excluding: .git/, .coding-agent/, .claude/, *.backup files, macOS metadata"
  puts ""

  Dir.chdir(SCRIPT_DIR)

  tar_cmd = "tar czf - --no-xattrs --exclude='.git' --exclude='.coding-agent' --exclude='.claude' --exclude='*.backup' --exclude='.DS_Store' --exclude='._*' --exclude='.codespace-defaults.yml' ."
  ssh_cmd = "gh codespace ssh -c #{codespace_name} -- 'mkdir -p ~/new-machine-bootstrap && cd ~/new-machine-bootstrap && tar xzf -'"
  sync_cmd = "#{tar_cmd} | #{ssh_cmd}"

  system(sync_cmd)

  unless $?.success?
    puts "Error: Failed to sync repository"
    exit 1
  end

  puts ""
  puts "==> Sync complete!"
  puts ""
  puts "==> Running provisioning in Codespace..."
  puts ""

  # Run provisioning with unbuffered output
  # Use bash -l (login shell) to source profile and get GH_TOKEN
  # script -q -e allocates a PTY for real-time output, -c runs the command, output goes to /dev/null (no typescript file)
  provision_cmd = %Q{gh codespace ssh -c #{codespace_name} -- 'script -q -e -c "bash -l -c \\"cd ~/new-machine-bootstrap && ./bin/provision\\"" /dev/null'}
  puts "Running: #{provision_cmd}"
  system(provision_cmd)

  puts ""
  puts "==> Provisioning complete!"
end

main
