#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'open3'

require_relative '../lib/coding_agent_syncer'

def command_exists?(cmd)
  system("command -v #{cmd} >/dev/null 2>&1")
end

def run_command(cmd, error_message: nil)
  stdout, stderr, status = Open3.capture3(cmd)
  unless status.success?
    puts "Error: #{error_message || "Command failed: #{cmd}"}"
    puts stderr unless stderr.empty?
    exit 1
  end
  stdout
end

def ensure_gh_installed
  return if command_exists?('gh')

  puts "Error: gh CLI is required but not installed"
  puts "Install it with: brew install gh"
  exit 1
end

def sync_coding_agent_from_codespace(codespace_name)
  puts "\n==> Disconnected from Codespace"

  local_path = File.join(Dir.pwd, '.coding-agent')
  return unless Dir.exist?(local_path)

  begin
    stdout, stderr, status = Open3.capture3("gh codespace list --json name,repository")
    return unless status.success?

    codespaces = JSON.parse(stdout)
    codespace_info = codespaces.find { |cs| cs['name'] == codespace_name }
    return unless codespace_info

    repo_full_name = codespace_info['repository']
    repo_name = repo_full_name.split('/').last
    remote_path = "/workspaces/#{repo_name}/.coding-agent"

    CodingAgentSyncer.sync_from_codespace(Dir.pwd, codespace_name, remote_path)
  rescue => e
    puts "Warning: Could not sync .coding-agent directory"
  end
end

def main
  ensure_gh_installed

  # Check if codespace name was provided as argument
  codespace_name_arg = ARGV[0]
  codespace_name = nil # This will hold the actual codespace name to SSH to

  if codespace_name_arg
    codespace_name = codespace_name_arg
    puts "==> Connecting to Codespace: #{codespace_name}"
  else
    puts "==> Finding available Codespaces..."

    codespaces_json = run_command(
      'gh codespace list --json name,repository,state,gitStatus',
      error_message: 'Failed to list Codespaces'
    )

    all_codespaces = JSON.parse(codespaces_json)

    all_codespaces.each do |cs|
      puts "Found Codespace #{cs['name']} in state '#{cs['state']}'"
    end

    if all_codespaces.empty?
      puts "\nError: No Codespaces found."
      puts "Create a new one: codespace-create"
      exit 1
    end

    puts ""
    codespaces = all_codespaces

    selected_display_string = if codespaces.size == 1
      cs = codespaces[0]
      "#{cs['name']} (Branch: #{cs['gitStatus']['ref']}, State: #{cs['state']})"
    else
      unless command_exists?('fzf')
        puts "Error: Multiple Codespaces found, but fzf is not installed"
        puts "Install fzf: brew install fzf"
        exit 1
      end

      puts "==> Multiple Codespaces found, please select one:"
      names_for_fzf = codespaces.map { |cs| "#{cs['name']} (Branch: #{cs['gitStatus']['ref']}, State: #{cs['state']})" }.join("\n")
      
      stdout, stderr, status = Open3.capture3('fzf --prompt="Select Codespace: "', stdin_data: names_for_fzf)

      unless status.success?
        puts "Error: No Codespace selected"
        exit 1
      end

      stdout.strip
    end
    
    puts "==> Connecting to Codespace: #{selected_display_string}"
    # Extract the actual codespace name from the fzf output string
    match = selected_display_string.match(/^(.*?)\s\(/)
    if match
      codespace_name = match[1]
    else
      codespace_name = selected_display_string # Fallback if for some reason it's just the name
    end
  end

  puts ""

  system("gh codespace ssh -c #{codespace_name}")
  ssh_exit_code = $?.exitstatus

  sync_coding_agent_from_codespace(codespace_name)

  exit ssh_exit_code
end

main