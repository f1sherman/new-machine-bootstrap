#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'open3'

require_relative '../lib/dev_env_syncer'

def command_exists?(cmd)
  system("command -v #{cmd} >/dev/null 2>&1")
end

def truncate(str, max_length)
  return str if str.length <= max_length

  str[0, max_length - 3] + '...'
end

def run_command(cmd, error_message: nil)
  stdout, stderr, status = Open3.capture3(cmd)
  unless status.success?
    puts "Error: #{error_message || "Command failed: #{cmd}"}"
    puts stderr unless stderr.empty?
    exit 1
  end
  stdout
end

def ensure_gh_installed
  return if command_exists?('gh')

  puts "Error: gh CLI is required but not installed"
  puts "Install it with: brew install gh"
  exit 1
end


def main
  ensure_gh_installed

  # Check if codespace name was provided as argument
  codespace_name_arg = ARGV[0]
  codespace_name = nil # This will hold the actual codespace name to SSH to

  if codespace_name_arg
    codespace_name = codespace_name_arg
    puts "==> Connecting to Codespace: #{codespace_name}"
  else
    puts "==> Finding available Codespaces..."

    codespaces_json = run_command(
      'gh codespace list --json name,repository,state,gitStatus',
      error_message: 'Failed to list Codespaces'
    )

    all_codespaces = JSON.parse(codespaces_json)

    if all_codespaces.empty?
      puts "Error: No Codespaces found."
      puts "Create a new one: codespace-create"
      exit 1
    end

    codespace_name = if all_codespaces.size == 1
      all_codespaces[0]['name']
    else
      unless command_exists?('fzf')
        puts "Error: Multiple Codespaces found, but fzf is not installed"
        puts "Install fzf: brew install fzf"
        exit 1
      end

      # Build formatted lines for fzf with dynamic column widths based on terminal size
      # Use tab delimiter so we can reliably extract the full name
      terminal_width = `tput cols`.to_i rescue 80
      # Account for: fzf left margin (~4 chars), gaps between columns (4 chars), STATE column (~10 chars)
      available_width = terminal_width - 18
      # Split remaining space: 35% for name, 65% for branch
      name_width = [(available_width * 0.35).to_i, 15].max
      branch_width = [(available_width * 0.65).to_i, 20].max

      header = format("%-#{name_width}s  %-#{branch_width}s  %s", 'NAME', 'BRANCH', 'STATE')

      lines = all_codespaces.map do |cs|
        full_name = cs['name']
        display_name = truncate(full_name, name_width)
        branch = truncate(cs.dig('gitStatus', 'ref') || 'unknown', branch_width)
        state = cs['state'] || 'unknown'

        display = format("%-#{name_width}s  %-#{branch_width}s  %s", display_name, branch, state)
        # Append full name after a tab (hidden from display via --with-nth)
        "#{display}\t#{full_name}"
      end

      input = lines.join("\n")

      stdout, _stderr, status = Open3.capture3(
        'fzf',
        '--delimiter', "\t",
        '--with-nth', '1',
        '--layout', 'reverse',
        '--header', header,
        '--prompt', 'Select Codespace: ',
        stdin_data: input
      )

      unless status.success?
        puts "Error: No Codespace selected"
        exit 1
      end

      # Extract the full codespace name (after the tab)
      stdout.strip.split("\t").last
    end

    puts "==> Connecting to Codespace: #{codespace_name}"
  end

  puts ""

  system("gh codespace ssh -c #{codespace_name}")
  ssh_exit_code = $?.exitstatus

  puts "\n==> Disconnected from codespace: #{codespace_name}"
  puts "To reconnect run: codespace-ssh #{codespace_name}"

  exit ssh_exit_code
end

main