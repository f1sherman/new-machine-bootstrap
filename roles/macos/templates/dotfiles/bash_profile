#!/bin/bash
# vi:filetype=sh
# vi:syntax=sh

# use vim to edit files
export EDITOR=vim

# Don't require merge commit editing for conflict-free merges, see http://git-blame.blogspot.com/2012/02/updates-to-git-merge-in-upcoming-1710.html
export GIT_MERGE_AUTOEDIT=no

# Increase bash history
export HISTSIZE='32768';
export HISTFILESIZE="${HISTSIZE}"

# Use UTF-8
export LANG='en_US.UTF-8'
export LC_ALL='en_US.UTF-8'

# Enable colors in ls
export CLICOLOR='true'

# Use solorized colors in ls
export LSCOLORS='gxfxbEaEBxxEhEhBaDaCaD'

### Alias ###
# View HTTP traffic
alias sniff="sudo ngrep -d 'en1' -t '^(GET|POST) ' 'tcp and port 80'"
alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""
# Scan ports on a host
alias portscan="nmap -Pn -p1-65535"
# List TCP connections
alias lstcp="lsof -i TCP -P"
# Fix solarized theme in tmux
alias tmux="TERM=screen-256color-bce tmux"
# Shortcut for updating
alias update='ruby <(curl -fsSL https://raw.githubusercontent.com/f1sherman/new-machine-bootstrap/main/macos)'
# Shortcuts for committing
alias c='git commit'
alias ca='git commit --all'
alias cm='git commit --message'
alias cam='git commit --all --message'
alias am='git add . && git commit --amend --no-edit'
# Shortcut for viewing diffs
alias d='git d'
# Shortcut for pushing
alias p='git publish'
alias pf='git publish --force-with-lease'
# Shortcut for git status
alias s='git status'
# Show Disk Use of subdirectories, sort by size
alias duss="du -d 1 -h | sort -hr | egrep -v ^0"
### End Alias ###

# Be more intelligent when autocompleting by also looking at the text after
# the cursor. For example, when the current line is "cd ~/src/mozil", and
# the cursor is on the "z", pressing Tab will not autocomplete it to "cd
# ~/src/mozillail", but to "cd ~/src/mozilla". (This is supported by the
# Readline used by Bash 4.)
set skip-completed-text on

# Make Tab autocomplete regardless of filename case
set completion-ignore-case on

# Immediately add a trailing slash when autocompleting symlinks to directories
set mark-symlinked-directories on

# Autocorrect typos in path names when using `cd`
shopt -s cdspell

# Use emacs mode at the command line
set -o emacs

# Print cheatsheet for a command
cheat() {
  curl cht.sh/"${1}"
}

# Check which process uses port
port() {
  lsof -i tcp:"${1}"
}

# Convenience functions for encrypting and decrypting files
encrypt() { openssl des3 -salt -in "$1" -out "$1.enc"; }
decrypt() { openssl des3 -d -salt -in "$1" -out "${1//\.enc/}"; }

# Add to path avoiding duplicates
pathadd() {
  local newdir=${1%/}
  if [ -d "${1}" ] && ! echo "${PATH}" | grep --extended-regexp --quiet "(^|:)$newdir($|:)"; then
    PATH="${newdir}:${PATH}"
  fi
}

pathadd "${HOME}/bin"

_worktree_main_branch() {
  local origin_head
  origin_head="$("$(_worktree_cmd git)" symbolic-ref -q --short refs/remotes/origin/HEAD 2>/dev/null || true)"
  if [[ -n "$origin_head" ]]; then
    echo "${origin_head#origin/}"
  elif "$(_worktree_cmd git)" show-ref --verify --quiet refs/heads/main; then
    echo "main"
  else
    echo "master"
  fi
}

_worktree_main_path() {
  local main_branch="$1" line main_path branch_name
  main_path=""
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      main_path="${line#worktree }"
    elif [[ "$line" == branch\ refs/heads/* ]]; then
      branch_name="${line#branch refs/heads/}"
      if [[ "$branch_name" == "$main_branch" ]]; then
        echo "$main_path"
        return 0
      fi
      main_path=""
    fi
  done < <("$(_worktree_cmd git)" worktree list --porcelain)
  return 1
}

_worktree_repo_root() {
  local root
  root=$(GIT_DIR= GIT_WORK_TREE= "$(_worktree_cmd git)" rev-parse --show-toplevel 2>/dev/null) || true
  if [[ -n "$root" ]]; then
    echo "$root"
    return 0
  fi
  "$(_worktree_cmd git)" rev-parse --show-toplevel 2>/dev/null
}

_worktree_debug() {
  [[ "${WORKTREE_DEBUG:-}" == "1" ]] || return 0
  echo "[worktree] $*" >&2
}

_worktree_sync_coding_agent_new_files() {
  local src="$1"
  local dst="$2"
  if [[ ! -d "$src" ]]; then
    return 0
  fi
  "$(_worktree_cmd mkdir)" -p "$dst"
  "$(_worktree_cmd cp)" -R -n "${src}/." "${dst}/"
}

_worktree_cmd() {
  local cmd="$1"
  local candidates=(
    "/opt/homebrew/bin/$cmd"
    "/usr/local/bin/$cmd"
    "/usr/bin/$cmd"
    "/bin/$cmd"
  )
  local path
  for path in "${candidates[@]}"; do
    if [[ -x "$path" ]]; then
      printf '%s\n' "$path"
      return 0
    fi
  done
  printf '%s\n' "$cmd"
}

worktree-start() {
  local branch path start_point print_path repo_root repo_name parent_dir safe_branch
  branch=""
  path=""
  start_point="HEAD"
  print_path="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--branch)
        branch="${2:-}"
        shift 2
        ;;
      -p|--path)
        path="${2:-}"
        shift 2
        ;;
      -f|--from)
        start_point="${2:-}"
        shift 2
        ;;
      --print-path)
        print_path="true"
        shift
        ;;
      -h|--help)
        cat <<'EOF'
Usage: worktree-start <branch> [path]
       worktree-start --branch <branch> [--path <path>] [--from <start-point>] [--print-path]

Creates a new git worktree and branch from the current repository.
Copies ~/.claude/settings.local.json into <worktree>/.claude/settings.local.json if present.
EOF
        return 0
        ;;
      -*)
        echo "Error: unknown option: $1" >&2
        return 1
        ;;
      *)
        if [[ -z "$branch" ]]; then
          branch="$1"
        elif [[ -z "$path" ]]; then
          path="$1"
        else
          echo "Error: unexpected argument: $1" >&2
          return 1
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$branch" ]]; then
    echo "Error: branch name is required" >&2
    return 1
  fi

  repo_root="$(_worktree_repo_root)"
  _worktree_debug "pwd=$PWD"
  _worktree_debug "git=$(_worktree_cmd git)"
  if [[ -x "$(_worktree_cmd printenv)" && -x "$(_worktree_cmd grep)" ]]; then
    _worktree_debug "GIT env=$("$(_worktree_cmd printenv)" | "$(_worktree_cmd grep)" '^GIT_' || true)"
  fi
  _worktree_debug "repo_root=${repo_root:-<empty>}"
  if [[ -z "$repo_root" ]]; then
    echo "Error: not inside a git repository" >&2
    return 1
  fi

  if [[ -z "$path" ]]; then
    repo_name=$("$(_worktree_cmd basename)" "$repo_root")
    parent_dir=$("$(_worktree_cmd dirname)" "$repo_root")
    safe_branch="${branch//\//-}"
    path="${parent_dir}/${repo_name}-${safe_branch}"
  fi

  if "$(_worktree_cmd git)" -C "$repo_root" show-ref --verify --quiet "refs/heads/$branch"; then
    echo "Error: branch already exists: $branch" >&2
    return 1
  fi

  if [[ -e "$path" ]]; then
    echo "Error: path already exists: $path" >&2
    return 1
  fi

  if ! "$(_worktree_cmd git)" -C "$repo_root" rev-parse --verify "$start_point" >/dev/null 2>&1; then
    echo "Error: invalid start point: $start_point" >&2
    return 1
  fi

  if ! "$(_worktree_cmd git)" -C "$repo_root" worktree add -b "$branch" "$path" "$start_point"; then
    echo "Error: failed to create worktree" >&2
    return 1
  fi

  _worktree_sync_coding_agent_new_files "${repo_root}/.coding-agent" "${path}/.coding-agent"

  if [[ -f "${HOME}/.claude/settings.local.json" && ! -e "${path}/.claude/settings.local.json" ]]; then
    "$(_worktree_cmd mkdir)" -p "${path}/.claude"
    "$(_worktree_cmd cp)" -p "${HOME}/.claude/settings.local.json" "${path}/.claude/settings.local.json"
  fi

  # Trust the new worktree directory in Claude Code
  if command -v claude-trust-directory >/dev/null 2>&1; then
    claude-trust-directory "$path" 2>/dev/null || true
  fi

  if [[ "$print_path" == "true" ]]; then
    printf '%s\n' "$path"
    return 0
  fi

  if command -v mise >/dev/null 2>&1; then
    mise trust "$path" >/dev/null 2>&1 || true
  fi

  cd "$path"
  echo "==> Worktree created:"
  echo "    Branch: $branch"
}

worktree-create() {
  worktree-start "$@"
}

worktree-cd() {
  worktree-start "$@"
}

worktree-merge() {
  local repo_root current_branch current_path main_branch main_path
  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }
  current_branch=$("$(_worktree_cmd git)" -C "$repo_root" branch --show-current)
  if [[ -z "$current_branch" ]]; then
    echo "Error: detached HEAD; checkout a branch first" >&2
    return 1
  fi
  current_path="$repo_root"
  main_branch="$(_worktree_main_branch)"
  if [[ "$current_branch" == "$main_branch" ]]; then
    echo "Error: already on ${main_branch}; this command is for non-main worktrees" >&2
    return 1
  fi
  if [[ -n "$("$(_worktree_cmd git)" -C "$current_path" status --porcelain)" ]]; then
    echo "Error: worktree has uncommitted changes; commit or stash first" >&2
    return 1
  fi
  main_path="$(_worktree_main_path "$main_branch")" || {
    echo "Error: could not find main worktree for branch ${main_branch}" >&2
    return 1
  }
  if [[ -n "$("$(_worktree_cmd git)" -C "$main_path" status --porcelain)" ]]; then
    echo "Error: main worktree has uncommitted changes; clean it first" >&2
    return 1
  fi
  "$(_worktree_cmd git)" -C "$main_path" checkout "$main_branch"
  "$(_worktree_cmd git)" -C "$main_path" merge "$current_branch"
  cd "$main_path"
  echo "==> Merged ${current_branch} into ${main_branch}:"
  echo "    Branch: ${current_branch}"
  echo "    Main: ${main_path}"
}

worktree-delete() {
  local repo_root current_branch current_path main_branch main_path
  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }
  current_branch=$("$(_worktree_cmd git)" -C "$repo_root" branch --show-current)
  if [[ -z "$current_branch" ]]; then
    echo "Error: detached HEAD; checkout a branch first" >&2
    return 1
  fi
  current_path="$repo_root"
  main_branch="$(_worktree_main_branch)"
  if [[ "$current_branch" == "$main_branch" ]]; then
    echo "Error: already on ${main_branch}; this command is for non-main worktrees" >&2
    return 1
  fi
  if [[ -n "$("$(_worktree_cmd git)" -C "$current_path" status --porcelain)" ]]; then
    echo "Error: worktree has uncommitted changes; commit or stash first" >&2
    return 1
  fi
  main_path="$(_worktree_main_path "$main_branch")" || {
    echo "Error: could not find main worktree for branch ${main_branch}" >&2
    return 1
  }
  cd "$main_path"
  "$(_worktree_cmd git)" -C "$main_path" worktree remove "$current_path"
  "$(_worktree_cmd git)" -C "$main_path" branch -D "$current_branch"
  echo "==> Removed worktree and deleted branch:"
  echo "    Branch: ${current_branch}"
  echo "    Path: ${current_path}"
}

worktree-done() {
  local repo_root current_branch current_path main_branch main_path
  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }
  current_branch=$("$(_worktree_cmd git)" -C "$repo_root" branch --show-current)
  if [[ -z "$current_branch" ]]; then
    echo "Error: detached HEAD; checkout a branch first" >&2
    return 1
  fi
  current_path="$repo_root"
  main_branch="$(_worktree_main_branch)"
  if [[ "$current_branch" == "$main_branch" ]]; then
    echo "Error: already on ${main_branch}; this command is for non-main worktrees" >&2
    return 1
  fi
  if [[ -n "$("$(_worktree_cmd git)" -C "$current_path" status --porcelain)" ]]; then
    echo "Error: worktree has uncommitted changes; commit or stash first" >&2
    return 1
  fi
  main_path="$(_worktree_main_path "$main_branch")" || {
    echo "Error: could not find main worktree for branch ${main_branch}" >&2
    return 1
  }
  if [[ -n "$("$(_worktree_cmd git)" -C "$main_path" status --porcelain)" ]]; then
    echo "Error: main worktree has uncommitted changes; clean it first" >&2
    return 1
  fi
  "$(_worktree_cmd git)" -C "$main_path" checkout "$main_branch"
  "$(_worktree_cmd git)" -C "$main_path" merge "$current_branch"
  "$(_worktree_cmd git)" -C "$main_path" push

  _worktree_sync_coding_agent_new_files "${current_path}/.coding-agent" "${main_path}/.coding-agent"

  cd "$main_path"
  "$(_worktree_cmd git)" -C "$main_path" worktree remove "$current_path"
  "$(_worktree_cmd git)" -C "$main_path" branch -D "$current_branch"
  echo "==> Merged ${current_branch} into ${main_branch} and removed worktree:"
  echo "    Branch: ${current_branch}"
  echo "    Path: ${current_path}"
}

wts() {
  worktree-start "$@"
}

wtd() {
  worktree-done "$@"
}

# Switch branches using fzf
b() {
  local branches branch
  branches=$(git --no-pager branch) &&
  branch=$(echo "$branches" | fzf +m) &&
  git checkout "$(echo "${branch}" | awk '{print $1}' | sed "s/.* //")"
}

# Use rg for FZF for speed and to respect .gitignore, .ignore
export FZF_DEFAULT_COMMAND='rg --files'

# Load any machine-specific customizations
if [ -f ~/.bash_profile.local ]; then
  # shellcheck disable=SC1090
  . ~/.bash_profile.local
fi

# Setup git completion and git bash prompt
GIT_COMPLETION_DIRECTORY="{{ brew_prefix }}/etc/bash_completion.d"

if [ -d "$GIT_COMPLETION_DIRECTORY" ]; then
  # shellcheck disable=SC1090
  source "$GIT_COMPLETION_DIRECTORY/git-completion.bash"
  # shellcheck disable=SC1090
  source "$GIT_COMPLETION_DIRECTORY/git-prompt.sh"
  export GIT_PS1_SHOWDIRTYSTATE=true
  export GIT_PS1_SHOWSTASHSTATE=true
  export GIT_PS1_SHOWUNTRACKEDFILES=true
  export GIT_PS1_SHOWUPSTREAM="auto"
else
  echo "Warning: unable to find git completion directory, git bash completion and prompt will not work"
fi

# Search the current bundle
bgrep() {
  # shellcheck disable=SC2046
  rg "$@" $(bundle show --paths)
}

export PROMPT_COMMAND=__prompt

function __prompt() {
  local LAST_EXIT="$?"
  PS1=""

  local REGULAR="\[\e[0m\]"
  local RED='\[\e[0;31m\]'

  # Make the prompt red if the last command failed
  if [ "$LAST_EXIT" != 0 ]; then
    PS1+="${RED}"
  fi

  PS1+="\w$(__git_ps1 " (%s)")\$${REGULAR} "
}

if [ -f ~/.bashrc ]; then
  # shellcheck disable=SC1090
  source ~/.bashrc
fi

# Load SSH keys into the keychain - http://stackoverflow.com/a/39715149/961521
ssh-add -A 2>/dev/null;

# Setup mise
if command -v mise > /dev/null; then eval "$(mise activate bash)"; fi
