#!/bin/zsh
# vim: set filetype=zsh syntax=zsh

# Use user-owned temp directory to avoid permission issues with system temp dir.
# After reboot, macOS sometimes creates /var/folders/*/T/ owned by root, which
# breaks tools like fzf that need to create temp files.
export TMPDIR="$HOME/.tmp"
mkdir -p "$TMPDIR"

# use vim to edit files
export EDITOR=nvim

# use nvim instead of vim
alias vim=nvim

memusage() {
    ps aux | grep -i "$1" | grep -v grep | while read -r line; do
        pid=$(echo "$line" | awk '{print $2}')
        ps -p "$pid" -o pid=,comm=,%mem=,rss= | awk '{printf "PID: %s  Command: %s  Mem: %s  RSS: %.2f MB\n", $1, $2, $3, $4/1024}'
    done
}

# Be more intelligent when autocompleting by also looking at the text after
# the cursor. For example, when the current line is "cd ~/src/mozil", and
# the cursor is on the "z", pressing Tab will not autocomplete it to "cd
# ~/src/mozillail", but to "cd ~/src/mozilla". (This is supported by the
# Readline used by Bash 4.)
set skip-completed-text on

# Make Tab autocomplete regardless of filename case
set completion-ignore-case on

# Immediately add a trailing slash when autocompleting symlinks to directories
set mark-symlinked-directories on

# Use vim mode at the command line
set -o vi

# Convenience functions for encrypting and decrypting files
encrypt() { gpg --symmetric "$1"; }
decrypt() { gpg -o "${1//\.enc/}" -d "$1"; }

# Create directory and change into it
mkcd() {
  \mkdir -p "$1"
  cd "$1"
}

_worktree_main_branch() {
  local origin_head
  origin_head=$(git symbolic-ref -q --short refs/remotes/origin/HEAD 2>/dev/null || true)
  if [[ -n "$origin_head" ]]; then
    echo "${origin_head#origin/}"
  elif git show-ref --verify --quiet refs/heads/main; then
    echo "main"
  else
    echo "master"
  fi
}

_worktree_main_path() {
  local main_branch="$1" line main_path branch_name
  main_path=""
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      main_path="${line#worktree }"
    elif [[ "$line" == branch\ refs/heads/* ]]; then
      branch_name="${line#branch refs/heads/}"
      if [[ "$branch_name" == "$main_branch" ]]; then
        echo "$main_path"
        return 0
      fi
      main_path=""
    fi
  done < <(git worktree list --porcelain)
  return 1
}

_worktree_repo_root() {
  GIT_DIR= GIT_WORK_TREE= command git rev-parse --show-toplevel 2>/dev/null
}

worktree-create() {
  local branch path start_point print_path repo_root repo_name parent_dir safe_branch
  branch=""
  path=""
  start_point="HEAD"
  print_path="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--branch)
        branch="${2:-}"
        shift 2
        ;;
      -p|--path)
        path="${2:-}"
        shift 2
        ;;
      -f|--from)
        start_point="${2:-}"
        shift 2
        ;;
      --print-path)
        print_path="true"
        shift
        ;;
      -h|--help)
        cat <<'EOF'
Usage: worktree-create <branch> [path]
       worktree-create --branch <branch> [--path <path>] [--from <start-point>] [--print-path]

Creates a new git worktree and branch from the current repository.
Copies ~/.claude/settings.local.json into <worktree>/.claude/settings.local.json if present.
EOF
        return 0
        ;;
      -*)
        echo "Error: unknown option: $1" >&2
        return 1
        ;;
      *)
        if [[ -z "$branch" ]]; then
          branch="$1"
        elif [[ -z "$path" ]]; then
          path="$1"
        else
          echo "Error: unexpected argument: $1" >&2
          return 1
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$branch" ]]; then
    echo "Error: branch name is required" >&2
    return 1
  fi

  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }

  if [[ -z "$path" ]]; then
    repo_name=$(basename "$repo_root")
    parent_dir=$(dirname "$repo_root")
    safe_branch="${branch//\//-}"
    path="${parent_dir}/${repo_name}-${safe_branch}"
  fi

  if git -C "$repo_root" show-ref --verify --quiet "refs/heads/$branch"; then
    echo "Error: branch already exists: $branch" >&2
    return 1
  fi

  if [[ -e "$path" ]]; then
    echo "Error: path already exists: $path" >&2
    return 1
  fi

  if ! git -C "$repo_root" rev-parse --verify "$start_point" >/dev/null 2>&1; then
    echo "Error: invalid start point: $start_point" >&2
    return 1
  fi

  git -C "$repo_root" worktree add -b "$branch" "$path" "$start_point"

  if [[ -f "${HOME}/.claude/settings.local.json" && ! -e "${path}/.claude/settings.local.json" ]]; then
    mkdir -p "${path}/.claude"
    cp -p "${HOME}/.claude/settings.local.json" "${path}/.claude/settings.local.json"
  fi

  if [[ "$print_path" == "true" ]]; then
    printf '%s\n' "$path"
    return 0
  fi

  if command -v mise >/dev/null 2>&1; then
    mise trust "$path" >/dev/null 2>&1 || true
  fi

  cd "$path"
  echo "==> Worktree created:"
  echo "    Branch: $branch"
  echo "    Path: $path"
}

worktree-cd() {
  worktree-create "$@"
}

worktree-merge() {
  local repo_root current_branch current_path main_branch main_path
  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }
  current_branch=$(git -C "$repo_root" branch --show-current)
  if [[ -z "$current_branch" ]]; then
    echo "Error: detached HEAD; checkout a branch first" >&2
    return 1
  fi
  current_path="$repo_root"
  main_branch="$(_worktree_main_branch)"
  if [[ "$current_branch" == "$main_branch" ]]; then
    echo "Error: already on ${main_branch}; this command is for non-main worktrees" >&2
    return 1
  fi
  if [[ -n "$(git -C "$current_path" status --porcelain)" ]]; then
    echo "Error: worktree has uncommitted changes; commit or stash first" >&2
    return 1
  fi
  main_path="$(_worktree_main_path "$main_branch")" || {
    echo "Error: could not find main worktree for branch ${main_branch}" >&2
    return 1
  }
  if [[ -n "$(git -C "$main_path" status --porcelain)" ]]; then
    echo "Error: main worktree has uncommitted changes; clean it first" >&2
    return 1
  fi
  git -C "$main_path" checkout "$main_branch"
  git -C "$main_path" merge "$current_branch"
  cd "$main_path"
  echo "==> Merged ${current_branch} into ${main_branch}:"
  echo "    Branch: ${current_branch}"
  echo "    Main: ${main_path}"
}

worktree-delete() {
  local repo_root current_branch current_path main_branch main_path
  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }
  current_branch=$(git -C "$repo_root" branch --show-current)
  if [[ -z "$current_branch" ]]; then
    echo "Error: detached HEAD; checkout a branch first" >&2
    return 1
  fi
  current_path="$repo_root"
  main_branch="$(_worktree_main_branch)"
  if [[ "$current_branch" == "$main_branch" ]]; then
    echo "Error: already on ${main_branch}; this command is for non-main worktrees" >&2
    return 1
  fi
  if [[ -n "$(git -C "$current_path" status --porcelain)" ]]; then
    echo "Error: worktree has uncommitted changes; commit or stash first" >&2
    return 1
  fi
  main_path="$(_worktree_main_path "$main_branch")" || {
    echo "Error: could not find main worktree for branch ${main_branch}" >&2
    return 1
  }
  if [[ -n "$(git -C "$main_path" status --porcelain)" ]]; then
    echo "Error: main worktree has uncommitted changes; clean it first" >&2
    return 1
  fi
  cd "$main_path"
  git -C "$main_path" worktree remove "$current_path"
  git -C "$main_path" branch -D "$current_branch"
  echo "==> Removed worktree and deleted branch:"
  echo "    Branch: ${current_branch}"
  echo "    Path: ${current_path}"
}

worktree-done() {
  local repo_root current_branch current_path main_branch main_path
  repo_root="$(_worktree_repo_root)" || {
    echo "Error: not inside a git repository" >&2
    return 1
  }
  current_branch=$(git -C "$repo_root" branch --show-current)
  if [[ -z "$current_branch" ]]; then
    echo "Error: detached HEAD; checkout a branch first" >&2
    return 1
  fi
  current_path="$repo_root"
  main_branch="$(_worktree_main_branch)"
  if [[ "$current_branch" == "$main_branch" ]]; then
    echo "Error: already on ${main_branch}; this command is for non-main worktrees" >&2
    return 1
  fi
  if [[ -n "$(git -C "$current_path" status --porcelain)" ]]; then
    echo "Error: worktree has uncommitted changes; commit or stash first" >&2
    return 1
  fi
  main_path="$(_worktree_main_path "$main_branch")" || {
    echo "Error: could not find main worktree for branch ${main_branch}" >&2
    return 1
  }
  if [[ -n "$(git -C "$main_path" status --porcelain)" ]]; then
    echo "Error: main worktree has uncommitted changes; clean it first" >&2
    return 1
  fi
  git -C "$main_path" checkout "$main_branch"
  git -C "$main_path" merge "$current_branch"
  cd "$main_path"
  git -C "$main_path" worktree remove "$current_path"
  git -C "$main_path" branch -D "$current_branch"
  echo "==> Merged ${current_branch} into ${main_branch} and removed worktree:"
  echo "    Branch: ${current_branch}"
  echo "    Path: ${current_path}"
}

# Create secure temporary directory and optionally a subdirectory within it
tempe() {
  cd "$(mktemp -d)"
  chmod -R 0700 .
  if [[ $# -eq 1 ]]; then
    \mkdir -p "$1"
    cd "$1"
    chmod -R 0700 .
  fi
}

# Convert web page to markdown using readability-cli and pandoc
2markdown() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: 2markdown <url>"
    return 1
  fi
  npx readability-cli "$1" | pandoc --from html --to gfm --wrap=none --output page.md
}

# Use rg for FZF for speed and to respect .gitignore, .ignore
export FZF_DEFAULT_COMMAND='rg --files'

# Don't list vcs-ignored files when using Ctrl-T because it can be very slow and we probably don't want it most of the
# time
export FZF_CTRL_T_COMMAND='rg --files --ignore-vcs'

# make CTRL-R paste the current query when there's no match
export FZF_CTRL_R_OPTS='--bind enter:accept-or-print-query'

if command -v brew >/dev/null 2>&1; then
  : "${HOMEBREW_PREFIX:=$(brew --prefix 2>/dev/null)}"
  if [[ -n "${HOMEBREW_PREFIX}" ]]; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      chmod go-w "${HOMEBREW_PREFIX}/share" 2>/dev/null
    fi

    if [ -d "${HOMEBREW_PREFIX}/share/zsh-completions" ]; then
      FPATH="${HOMEBREW_PREFIX}/share/zsh-completions:$FPATH"
    fi
  fi
fi

# Search the current bundle
bgrep() {
  # shellcheck disable=SC2046
  rg "$@" $(bundle list --paths)
}

# Load SSH keys into the keychain - http://stackoverflow.com/a/39715149/961521
if [[ "$OSTYPE" == "darwin"* ]]; then
  ssh-add -A 2>/dev/null
fi

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"

  # Disable history expansion verification
  unsetopt histverify
fi

# Enable Ctrl-N and Ctrl-P to scroll command history
bindkey "^N" down-line-or-search
bindkey "^P" up-line-or-search


[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Switch branches using fzf
alias b > /dev/null && unalias b
function b() {
  local branches branch
  branches=$(git --no-pager branch) &&
    branch=$(echo "$branches" | fzf +m) &&
    git checkout "$(echo "${branch}" | awk '{print $1}' | sed "s/.* //")"
  }

# Delete branches using fzf
alias db > /dev/null && unalias db
function db() {
  local branches branch
  branches=$(git --no-pager branch) &&
    branch=$(echo "$branches" | fzf +m) &&
    git branch -D "$(echo "${branch}" | awk '{print $1}' | sed "s/.* //")"
  }

# Interactive rebase against main branch
function rebase() {
  git checkout main
  git pull
  git checkout -

  # Set up origin tracking if not already configured
  local current_branch=$(git branch --show-current)
  if ! git config --get branch.${current_branch}.remote > /dev/null 2>&1; then
    git push -u origin ${current_branch}
  else
    git pull
  fi

  git rebase -i main
}

### Alias ###
# View HTTP traffic
if [[ "$OSTYPE" == "darwin"* ]]; then
  alias sniff="sudo ngrep -d 'en1' -t '^(GET|POST) ' 'tcp and port 80'"
  alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""
fi
# Scan ports on a host
alias portscan="nmap -Pn -p1-65535"
# Fix solarized theme in tmux
alias tmux="TERM=screen-256color-bce tmux"
# Shortcut for updating
alias update='ruby <(curl -fsSL https://raw.githubusercontent.com/f1sherman/new-machine-bootstrap/main/macos)'
# Shortcuts for committing
alias c='git commit'
alias ca='git commit --all'
alias cm='git commit --message'
alias cam='git commit --all --message'
alias am='git add . && git commit --amend --no-edit'
# Shortcut for viewing diffs
alias d='git d'
# Shortcut for pushing
alias p='git publish'
alias pf='git publish --force-with-lease'
# Shortcut for git status
alias s='git status'
# Show Disk Use of subdirectories, sort by size
alias duss="du -d 1 -h | sort -hr"

### End Alias ###

# Update tmux window name on directory change and before each prompt
if [[ -n "$TMUX" ]]; then
  _tmux_window_name_update() {
    command tmux-session-name &>/dev/null &!
  }
  autoload -Uz add-zsh-hook
  add-zsh-hook chpwd _tmux_window_name_update
  add-zsh-hook precmd _tmux_window_name_update
fi

# Load any machine-specific customizations
if [ -f ~/.zshrc.local ]; then
  # shellcheck disable=SC1090
  . ~/.zshrc.local
fi

# Only initialize mise here for non-login shells. For login shells, it will be
# initialized in zlogin
if [[ ! -o login ]]; then
  if command -v mise > /dev/null; then eval "$(mise activate zsh)"; fi
fi

# The following lines have been added by Docker Desktop to enable Docker CLI completions.
fpath=($HOME/.docker/completions $fpath)
autoload -Uz compinit
compinit
# End of Docker CLI completions
